<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308094 (ko-KR, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4422"/>

<div>
<span><div><div>chess_user-manual </div><div><br/></div><div><br/></div><div><b style="font-size: 18pt;"><br/></b></div><div><b style="font-size: 18pt;">1.Command Line Interface to Chess </b><br/></div><hr/><div><br/></div><div>chess 는 chess DE라는 GUI  tool 도 제공하지만 CLI 환경에서 할 수 있도록 chesscc 커멘드를 통해 제공한다.</div><div><br/></div><div><font style="font-size: 16pt;"><b>1.1 Tutorial</b></font></div><div><font style="font-size: 16pt;"><b><br/></b></font></div><div><font size="1"><b style="font-size: 14pt;">1.1.1 Example Project <br/></b></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;stdio.h&gt;</div><div>#include &lt;assert.h&gt;</div><div><br/></div><div>int fibonacci(int n)</div><div>{</div><div><span>    assert(n &gt;= 1);</span><br/></div><div><span><span>    int f1 = 1, f2 = 1;</span><br/></span></div><div><span><span>    while(n-- &gt; 2){</span><br/></span></div><div><span><span>    </span><span>    int f3 = f2 + f1;</span><br/></span></div><div><span><span>    </span><span>    f1 = f2;</span><br/></span></div><div><span><span>    </span><span>    f2 = f3;</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    return f2;</span><br/></span></div><div>}</div><div><br/></div><div>int main()</div><div>{</div><div><span>    for(int i=1; i&lt;=10; ++i)</span><br/></div><div><span><span>    </span><span>    printf(&quot;fibonacci(%d) = %d\n&quot;, i, fibonacci(i));</span><br/></span></div><div><span><span>    return 0;</span><br/></span></div><div>}</div></div><div><br/></div><div>이 코드를 돌려보자.</div><div><br/></div><div>stdio.h 불러와하야고 거기서 printf 까지 사용해야한다. </div><div><br/></div><div>=&gt; compile, link 하는 방법알아야 한다. 다룰 것 </div><div><br/></div><div><font style="font-size: 14pt;"><b>1.1.2 Specifying the Processor </b></font></div><div><br/></div><div>Chess compiler : retargetable compiler. </div><div> </div><div>프로세서 모델과 directory가 특정되어야 한다. </div><div><br/></div><div>Processor model directory 는 processor project file 을 포함해야한다</div><div><br/></div><div>&lt;processor&gt;.prx</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">-p &lt;processor&gt; 과 -P &lt;dir&gt; option 을 통해 이것을 특정할 수 있다. </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">예를 들어 tmicro가 processor name이고 ../lib 가 processor model directory라면 </span>invocation</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">% chesscc -c fib.c -p tmicro -P ../lib</span></div></div><div><br/></div><div>processor model directory 안에 processor.prx 를 두고 몇가지 pre-configured option을 적용해야한다.</div><div>ex : C library header, C library archive for linking, etc</div><div>이러한 옵션 chesscc라는 기도하는 것으로 다 자동으로 해결 </div><div><br/></div><div>Compiler Processor Header 필요하다. </div><div>파일명은 &lt;processor&gt;_chess.h (chess 가 compile 이라는 뜻으로 사용되는듯)</div><div><br/></div><ul><li><div>target processor 에서 사용할 수 있는 C built-in type과 operation 이 명시되어 있다. <br/></div></li></ul><div>또 명시되어있는 것중에서 필요없는 것 뺄 수도 있다. 당연히 뺀 다음 그것을 코드에서 사용하면 컴파일에 실패한다. </div><div><br/></div><ul><li><div>추가적인 basic data type 도 추가해서 정의할 수 있다. 전형적인 예는 fixed-point type, accumulator types, complex types, and vector or SIMD(single instruction multiple data stream) types</div></li></ul><div><br/></div><div><br/></div><div><b><font style="font-size: 14pt;">1.1.3 Compiling </font></b></div><div><br/></div><div>컴파일 명령은 </div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>chesscc -c fib.c</div></div><div><br/></div><div>로 할 수 있다. </div><div><br/></div><div>이 과정은 fib.o 파일을 생성한다. (ELF object file)</div><div>object 파일을 만드는데 같은 폴더에 헤더파일이 위치한 것이 아니라면 </div><div>-I 옵션을 통해 헤더파일 위치를 지정해 주어야 한다. </div><div><br/></div><div>이 과정은 assemble 한다음 binary 코드로 가는게 아니라 바로 바이너리로 간다. </div><div>만약 어셈블리 코드가 궁금하다면 </div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>chesscc -c -d fib.c </div></div><div><br/></div><div>를 해서 기계어를 다시 디어셈블 하게 하면 된다. </div><div><br/></div><div><b><font style="font-size: 12pt;">LLVM Front End </font></b></div><div><br/></div><div>프로세서 모델의 broad class 를 위해 chess-clang 을 enable 하게 할 수 있다. </div><div>LLVM based front end 를 chess compiler 에 적용한다. </div><div>더 aggressive 한 최적화를 제공하고 C++을 지원한다. </div><div>-f option을 통해 제공할 수 있고 -C옵션을 주어 관련된 string 을 추가한다(like LLVM-specific processor header and runtime libraries)</div><div><br/></div><div><b><font style="font-size: 12pt;">Compiler Phases and Parallel Compilation </font></b></div><div><br/></div><div>다음에 </div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>% chesscc -c -f -C Release_LLVM fib.c </div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>참고 - ELF https://ko.wikipedia.org/wiki/ELF_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">x86 기반 유닉스, 유닉스 계열 시스템들의 표준 바이너리 파일형식으로 선택되었다. </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">실행파일, 목적파일, 공유 라이브러리, 코어덤프를 위한 표준 파일 형식</span></div></div><div> <br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">참고 - LLVM(Low Level Virtual Machine) -</span>https://ko.wikipedia.org/wiki/LLVM</div><div><br/></div><div>컴파일러의 기반구조. 프로그램을 컴파일 타임, 링크 타임, 런타임 상황에서 프로그램의 작성 언어에 상관없이</div><div>최적화를 쉽게 구현할 수 있도록 구성되어 있다. </div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 